name: "Pipeline: Scrape & Analyze Production [manual, self-hosted]"
# Manually triggered workflow to scrape news and optionally run analysis.
# NOTE: This workflow requires the self-hosted runner to have 'uv' installed.

permissions:
  pull-requests: read
  contents: read
  checks: write

on:
  workflow_dispatch:
    inputs:
      config:
        description: 'Config key to use for scraping'
        required: true
        type: choice
        options:
          - israel
          - oesterreich
          - technology
          - world_politics
          - world
          - test
          - test_ollama
      run_analysis:
        description: 'Run analysis after scraping'
        required: false
        default: true
        type: boolean
      llm_provider:
        description: 'LLM provider to use'
        required: true
        default: 'gemini'
        type: choice
        options:
          - gemini
          - ollama

jobs:
  scrape-and-analyze:
    runs-on: self-hosted
    environment: development
    
    steps:
      - name: Find open PR for branch
        id: pr
        uses: ./.github/actions/find-pr
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create check run
        id: create_check
        if: steps.pr.outputs.pr_found == 'true'
        uses: ./.github/actions/update-pr-status
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          sha: ${{ steps.pr.outputs.sha }}
          context: 'Check Scrape and Analyze'
          state: 'pending'
          description: 'Scraping and analyzing...'
          create-check-run: 'true'
          check-run-name: 'Check Scrape and Analyze'

      - name: Checkout code
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Install dependencies
        run: uv sync

      - name: Run migrations
        run: uv run ./src/web/manage.py migrate
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Run scraper
        id: scraper
        run: uv run newsbot run --config ${{ inputs.config }}
        env:
          EMAIL_ENABLED: 'true'
          EMAIL_SMTP_SERVER: ${{ vars.EMAIL_SMTP_SERVER }}
          EMAIL_SMTP_PORT: ${{ vars.EMAIL_SMTP_PORT }}
          EMAIL_USE_SSL: ${{ vars.EMAIL_USE_SSL }}
          EMAIL_SENDER: ${{ vars.EMAIL_SENDER }}
          EMAIL_RECIPIENT: ${{ vars.EMAIL_RECIPIENT }}
          EMAIL_FOR_CANCELLATION: ${{ vars.EMAIL_FOR_CANCELLATION }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          GEMINI_API_KEY: ${{ inputs.llm_provider == 'gemini' && secrets.GEMINI_API_KEY || '' }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Run analysis
        id: analysis
        if: ${{ inputs.run_analysis }}
        run: uv run newsbot analyze --config ${{ inputs.config }} --email-receivers 2>&1 | tee analysis_output.log
        env:
          EMAIL_ENABLED: 'true'
          EMAIL_SMTP_SERVER: ${{ vars.EMAIL_SMTP_SERVER }}
          EMAIL_SMTP_PORT: ${{ vars.EMAIL_SMTP_PORT }}
          EMAIL_USE_SSL: ${{ vars.EMAIL_USE_SSL }}
          EMAIL_SENDER: ${{ vars.EMAIL_SENDER }}
          EMAIL_RECIPIENT: ${{ vars.EMAIL_RECIPIENT }}
          EMAIL_FOR_CANCELLATION: ${{ vars.EMAIL_FOR_CANCELLATION }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          GEMINI_API_KEY: ${{ inputs.llm_provider == 'gemini' && secrets.GEMINI_API_KEY || '' }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}

      - name: Verify email was sent
        if: ${{ inputs.run_analysis && steps.analysis.outcome == 'success' }}
        run: |
          if grep -q "Email sent successfully" analysis_output.log; then
            echo "✅ Email was sent successfully"
          else
            echo "⚠️ Email may not have been sent"
            echo "--- Analysis output ---"
            cat analysis_output.log
          fi

      - name: Write workflow summary
        if: always()
        run: |
          echo "## Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Config:** ${{ inputs.config }}" >> $GITHUB_STEP_SUMMARY
          echo "- **LLM Provider:** ${{ inputs.llm_provider }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Scraper:** ${{ steps.scraper.outcome }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ inputs.run_analysis }}" == "true" ]; then
            echo "- **Analysis:** ${{ steps.analysis.outcome }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Analysis:** skipped" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Update check run
        if: always() && steps.pr.outputs.pr_found == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const checkRunId = process.env.CHECK_RUN_ID;

            // Determine step outcomes
            const scraper = process.env.SCRAPER_OUTCOME || 'failure';
            const analysis = process.env.ANALYSIS_OUTCOME || 'skipped';
            const runAnalysis = process.env.RUN_ANALYSIS === 'true';

            // Determine if passed
            const scraperPassed = scraper === 'success';
            const analysisPassed = !runAnalysis || analysis === 'success';
            const allPassed = scraperPassed && analysisPassed;
            const conclusion = allPassed ? 'success' : 'failure';

            // Build summary message
            let summary = '';
            if (allPassed) {
              summary = runAnalysis ? 'Scrape and analysis completed successfully' : 'Scrape completed successfully (analysis skipped)';
            } else {
              const failed = [];
              if (scraper !== 'success') failed.push('Scraper');
              if (runAnalysis && analysis !== 'success') failed.push('Analysis');
              summary = `Failed: ${failed.join(', ')}`;
            }

            if (checkRunId) {
              await github.rest.checks.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                check_run_id: parseInt(checkRunId),
                status: 'completed',
                conclusion: conclusion,
                completed_at: new Date().toISOString(),
                output: {
                  title: 'Scrape and Analyze result',
                  summary: summary
                }
              });
            }
        env:
          CHECK_RUN_ID: ${{ steps.create_check.outputs.check-run-id }}
          SCRAPER_OUTCOME: ${{ steps.scraper.outcome }}
          ANALYSIS_OUTCOME: ${{ steps.analysis.outcome }}
          RUN_ANALYSIS: ${{ inputs.run_analysis }}

