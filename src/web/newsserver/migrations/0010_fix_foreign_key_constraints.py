# Generated by Django 6.0 on 2026-01-16 17:49

from django.db import migrations


def fix_foreign_key_constraints_forward(apps, schema_editor):
    """Fix foreign key constraints to point to newsserver_newsconfig instead of newsserver_newsconfiguration."""
    db_vendor = schema_editor.connection.vendor
    
    with schema_editor.connection.cursor() as cursor:
        if db_vendor == "postgresql":
            # Fix AnalysisSummary foreign key
            analysissummary_table = "newsserver_analysissummary"
            scrapesummary_table = "newsserver_scrapesummary"
            correct_table = "newsserver_newsconfig"
            
            # First, fix orphaned data - set config_id to NULL for records that reference non-existent configs
            cursor.execute(
                f""" 
                UPDATE "{analysissummary_table}" 
                SET config_id = NULL 
                WHERE config_id IS NOT NULL 
                AND config_id NOT IN (SELECT id FROM "{correct_table}");
                """ # nosec
            )
            
            cursor.execute(
                f"""
                UPDATE "{scrapesummary_table}" 
                SET config_id = NULL 
                WHERE config_id IS NOT NULL 
                AND config_id NOT IN (SELECT id FROM "{correct_table}");
                """ # nosec
            )
            
            # Find all foreign key constraints on AnalysisSummary that reference config_id
            cursor.execute(
                """
                SELECT 
                    tc.constraint_name,
                    kcu.column_name,
                    ccu.table_name AS foreign_table_name
                FROM information_schema.table_constraints AS tc 
                JOIN information_schema.key_column_usage AS kcu
                  ON tc.constraint_name = kcu.constraint_name
                  AND tc.table_schema = kcu.table_schema
                JOIN information_schema.constraint_column_usage AS ccu
                  ON ccu.constraint_name = tc.constraint_name
                  AND ccu.table_schema = tc.table_schema
                WHERE tc.table_schema = 'public'
                AND tc.table_name = %s
                AND tc.constraint_type = 'FOREIGN KEY'
                AND kcu.column_name = 'config_id';
                """,
                [analysissummary_table],
            )
            constraints = cursor.fetchall()
            
            for constraint_name, column_name, foreign_table in constraints:
                # Drop the constraint regardless of what it points to, then recreate correctly
                cursor.execute(  # nosec B608
                    f'ALTER TABLE "{analysissummary_table}" DROP CONSTRAINT IF EXISTS "{constraint_name}";'
                )
                # Recreate with correct reference
                cursor.execute(  # nosec B608
                    f"""
                    ALTER TABLE "{analysissummary_table}" 
                    ADD CONSTRAINT "{constraint_name}" 
                    FOREIGN KEY ("{column_name}") 
                    REFERENCES "{correct_table}" ("id") 
                    DEFERRABLE INITIALLY DEFERRED;
                    """
                )
            
            # Find all foreign key constraints on ScrapeSummary that reference config_id
            cursor.execute(
                """
                SELECT 
                    tc.constraint_name,
                    kcu.column_name,
                    ccu.table_name AS foreign_table_name
                FROM information_schema.table_constraints AS tc 
                JOIN information_schema.key_column_usage AS kcu
                  ON tc.constraint_name = kcu.constraint_name
                  AND tc.table_schema = kcu.table_schema
                JOIN information_schema.constraint_column_usage AS ccu
                  ON ccu.constraint_name = tc.constraint_name
                  AND ccu.table_schema = tc.table_schema
                WHERE tc.table_schema = 'public'
                AND tc.table_name = %s
                AND tc.constraint_type = 'FOREIGN KEY'
                AND kcu.column_name = 'config_id';
                """,
                [scrapesummary_table],
            )
            constraints = cursor.fetchall()
            
            for constraint_name, column_name, foreign_table in constraints:
                # Drop the constraint regardless of what it points to, then recreate correctly
                cursor.execute(  # nosec B608
                    f'ALTER TABLE "{scrapesummary_table}" DROP CONSTRAINT IF EXISTS "{constraint_name}";'
                )
                # Recreate with correct reference
                cursor.execute(  # nosec B608
                    f"""
                    ALTER TABLE "{scrapesummary_table}" 
                    ADD CONSTRAINT "{constraint_name}" 
                    FOREIGN KEY ("{column_name}") 
                    REFERENCES "{correct_table}" ("id") 
                    DEFERRABLE INITIALLY DEFERRED;
                    """
                )
        else:  # sqlite
            # SQLite doesn't support dropping foreign keys easily
            # The foreign key constraints are usually enforced at the application level
            # If needed, we'd have to recreate the tables, which is complex
            # For now, just pass - SQLite should work with the correct table references
            pass


def fix_foreign_key_constraints_reverse(apps, schema_editor):
    """Reverse migration - no-op."""
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('newsserver', '0009_fix_subscriber_configs_column_name'),
    ]

    operations = [
        migrations.RunPython(
            fix_foreign_key_constraints_forward,
            fix_foreign_key_constraints_reverse,
        ),
    ]
